/**
 * Automatic type generation system that detects user projects
 * and generates precise TypeScript types from their config files
 */

import {
	existsSync,
	statSync,
	readFileSync,
	writeFileSync,
	readdirSync,
	mkdirSync,
} from 'node:fs'
import { join, dirname } from 'node:path'
import { createHash } from 'node:crypto'

interface AutoTypeOptions {
	configDir?: string
	outputFile?: string
	force?: boolean
}

let hasGeneratedTypes = false

/**
 * Detect if we're running in a user project by checking for a config directory
 */
function detectUserProject(): string | null {
	const currentDir = process.cwd()
	const configPath = join(currentDir, 'config')

	if (existsSync(configPath) && statSync(configPath).isDirectory()) {
		return currentDir
	}

	return null
}

/**
 * Get the config directory path (always config/ at project root)
 */
function getConfigDirectory(
	projectRoot: string,
	customConfigDir?: string,
): string {
	if (customConfigDir) {
		return join(projectRoot, customConfigDir)
	}
	return join(projectRoot, 'config')
}

/**
 * Calculate hash of all config files content
 */
function getConfigHash(configDir: string): string {
	const files = readdirSync(configDir)
		.filter(file => file.endsWith('.json'))
		.sort()

	let combinedContent = ''
	for (const file of files) {
		const filePath = join(configDir, file)
		combinedContent += readFileSync(filePath, 'utf-8')
	}

	return createHash('md5').update(combinedContent).digest('hex')
}

/**
 * Check if config files have changed since last generation
 */
function hasConfigChanged(configDir: string, outputFile: string): boolean {
	if (!existsSync(outputFile)) return true

	try {
		// Read the hash from the generated file header
		const generatedContent = readFileSync(outputFile, 'utf-8')
		const hashMatch = generatedContent.match(
			/Generated hash: ([a-f0-9]{32})/,
		)

		if (!hashMatch) return true

		const oldHash = hashMatch[1]
		const newHash = getConfigHash(configDir)

		return oldHash !== newHash
	} catch {
		return true
	}
}

/**
 * Generate types using our existing generator
 */
async function generateTypes(
	configDir: string,
	outputFile: string,
): Promise<void> {
	try {
		// Ensure types directory exists
		const typesDir = dirname(outputFile)
		if (!existsSync(typesDir)) {
			mkdirSync(typesDir, { recursive: true })
		}

		// Import our generator
		// eslint-disable-next-line @typescript-eslint/no-require-imports
		const { generateConfigTypes } = require('./generate-types.cjs')
		const typeContent = generateConfigTypes(configDir)

		// Add hash to the generated content for change detection
		const configHash = getConfigHash(configDir)
		const contentWithHash = typeContent.replace(
			'* DO NOT EDIT MANUALLY - This file is automatically generated',
			`* DO NOT EDIT MANUALLY - This file is automatically generated\n * Generated hash: ${configHash}`,
		)

		writeFileSync(outputFile, contentWithHash)
		console.log(`✅ Generated config types: ${outputFile}`)
	} catch (error) {
		console.error(`❌ Failed to generate config types:`, error)
		throw error
	}
}

/**
 * Main automatic type generation function
 * This is called automatically when functions-server is imported in a user project
 */
export async function autoGenerateTypes(
	options: AutoTypeOptions = {},
): Promise<boolean> {
	// Skip if already generated this session (unless forced)
	if (hasGeneratedTypes && !options.force) {
		return true
	}

	// Detect user project
	const projectRoot = detectUserProject()
	if (!projectRoot) {
		// We're not in a user project (maybe in development of functions-server itself)
		return false
	}

	// Get config directory
	const configDir = getConfigDirectory(projectRoot, options.configDir)
	if (!existsSync(configDir)) {
		throw new Error(
			`Config directory not found: ${configDir}. Make sure the config directory exists or specify a custom path via configDir option.`,
		)
	}

	// Determine output file
	const outputFile =
		options.outputFile || join(projectRoot, 'types', 'config.d.ts')

	// Check if generation is needed
	if (!options.force && !hasConfigChanged(configDir, outputFile)) {
		hasGeneratedTypes = true
		return true
	}

	try {
		await generateTypes(configDir, outputFile)
		hasGeneratedTypes = true
		return true
	} catch (error) {
		console.error('❌ Auto type generation failed:', error)
		return false
	}
}

/**
 * Reset generation state (useful for testing)
 */
export function resetAutoGeneration(): void {
	hasGeneratedTypes = false
}
