#!/usr/bin/env node

/**
 * Generate TypeScript type definitions from JSON configuration files
 * This script reads JSON config files and creates precise TypeScript types
 */

const { readFileSync, writeFileSync, readdirSync, existsSync } = require('fs')
const { join, extname, basename } = require('path')

/**
 * Convert a JSON value to its TypeScript type representation
 */
function jsonToTypeScript(value, depth = 0) {
	const indent = '  '.repeat(depth)

	if (value === null) return 'null'
	if (typeof value === 'string') return 'string'
	if (typeof value === 'number') return 'number'
	if (typeof value === 'boolean') return 'boolean'

	if (Array.isArray(value)) {
		if (value.length === 0) return 'unknown[]'
		// Infer array element type from first element
		const elementType = jsonToTypeScript(value[0], depth)
		return `${elementType}[]`
	}

	if (typeof value === 'object' && value !== null) {
		const keys = Object.keys(value)

		if (keys.length === 0) return 'Record<string, unknown>'

		const properties = keys
			.map(key => {
				const propType = jsonToTypeScript(value[key], depth + 1)
				const optional =
					value[key] === null || value[key] === undefined ? '?' : ''
				return `${indent}  ${key}${optional}: ${propType}`
			})
			.join('\n')

		return `{\n${properties}\n${indent}}`
	}

	return 'unknown'
}

/**
 * Deep merge two objects recursively
 */
function deepMerge(target, source) {
	const result = { ...target }

	for (const key in source) {
		if (source.hasOwnProperty(key)) {
			if (
				typeof source[key] === 'object' &&
				source[key] !== null &&
				!Array.isArray(source[key]) &&
				typeof result[key] === 'object' &&
				result[key] !== null &&
				!Array.isArray(result[key])
			) {
				result[key] = deepMerge(result[key], source[key])
			} else {
				result[key] = source[key]
			}
		}
	}

	return result
}

/**
 * Merge multiple JSON objects and infer their combined type
 */
function mergeJsonTypes(configs) {
	// Start with default config as base
	let mergedStructure = configs.default || {}

	// Merge all environment configs to get all possible properties
	Object.entries(configs).forEach(([env, config]) => {
		if (
			env !== 'default' &&
			typeof config === 'object' &&
			!Array.isArray(config)
		) {
			mergedStructure = deepMerge(mergedStructure, config)
		}
	})

	return jsonToTypeScript(mergedStructure)
}

/**
 * Generate TypeScript declaration from JSON config files
 */
function generateConfigTypes(configDir) {
	if (!existsSync(configDir)) {
		throw new Error(`Config directory not found: ${configDir}`)
	}

	const files = readdirSync(configDir).filter(
		file => extname(file) === '.json',
	)

	if (files.length === 0) {
		throw new Error(`No JSON config files found in: ${configDir}`)
	}

	const configs = {}

	// Load all config files
	files.forEach(file => {
		const filePath = join(configDir, file)
		const configName = basename(file, '.json')

		try {
			const content = readFileSync(filePath, 'utf-8')
			configs[configName] = JSON.parse(content)
		} catch (error) {
			console.warn(`Warning: Failed to parse ${file}:`, error)
		}
	})

	// Generate merged type structure
	const typeDefinition = mergeJsonTypes(configs)

	// Generate the module declaration
	return `/**
 * Auto-generated type definitions from JSON configuration files
 * Generated from: ${configDir}
 * DO NOT EDIT MANUALLY - This file is automatically generated
 */

declare module '@nextnode/functions-server' {
  interface UserConfigSchema ${typeDefinition}
}

export {}
`
}

/**
 * CLI usage
 */
function main() {
	const configDir = process.argv[2] || './config'
	const outputFile = process.argv[3] || './config.d.ts'

	try {
		const typeDeclaration = generateConfigTypes(configDir)
		writeFileSync(outputFile, typeDeclaration)
		console.log(`‚úÖ Generated config types: ${outputFile}`)
		console.log(`üìÅ From config directory: ${configDir}`)
	} catch (error) {
		console.error('‚ùå Failed to generate config types:', error)
		process.exit(1)
	}
}

// Export for use as module
module.exports = { generateConfigTypes }

// Run if called directly
if (require.main === module) {
	main()
}