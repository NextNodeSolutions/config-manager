#!/usr/bin/env node

/**
 * Generate TypeScript type definitions from JSON configuration files
 * This script reads JSON config files and creates precise TypeScript types
 */

import {
	readFileSync,
	writeFileSync,
	readdirSync,
	existsSync,
	mkdirSync,
} from 'node:fs'
import { join, extname, basename, dirname } from 'node:path'

/**
 * Convert a JSON value to its TypeScript type representation
 */
function jsonToTypeScript(value, depth = 0) {
	const indent = '  '.repeat(depth)

	if (value === null) return 'null'
	if (typeof value === 'string') return 'string'
	if (typeof value === 'number') return 'number'
	if (typeof value === 'boolean') return 'boolean'

	if (Array.isArray(value)) {
		if (value.length === 0) return 'readonly unknown[]'
		// Infer array element type from first element
		const elementType = jsonToTypeScript(value[0], depth)
		return `readonly ${elementType}[]`
	}

	if (typeof value === 'object' && value !== null) {
		const keys = Object.keys(value)

		if (keys.length === 0) return 'Record<string, unknown>'

		const properties = keys
			.map(key => {
				const propType = jsonToTypeScript(value[key], depth + 1)
				// No optional properties - config should be complete and well-defined
				return `${indent}  readonly ${key}: ${propType}`
			})
			.join('\n')

		return `{\n${properties}\n${indent}}`
	}

	return 'unknown'
}

/**
 * Deep merge two objects recursively
 */
function deepMerge(target, source) {
	const result = { ...target }

	for (const key in source) {
		if (Object.prototype.hasOwnProperty.call(source, key)) {
			if (
				typeof source[key] === 'object' &&
				source[key] !== null &&
				!Array.isArray(source[key]) &&
				typeof result[key] === 'object' &&
				result[key] !== null &&
				!Array.isArray(result[key])
			) {
				result[key] = deepMerge(result[key], source[key])
			} else {
				result[key] = source[key]
			}
		}
	}

	return result
}

/**
 * Merge multiple JSON objects and infer their combined type
 */
function mergeJsonTypes(configs) {
	// Start with default config as base
	let mergedStructure = configs.default || {}

	// Merge all environment configs to get all possible properties
	Object.entries(configs).forEach(([env, config]) => {
		if (
			env !== 'default' &&
			typeof config === 'object' &&
			!Array.isArray(config)
		) {
			mergedStructure = deepMerge(mergedStructure, config)
		}
	})

	return jsonToTypeScript(mergedStructure)
}

/**
 * Generate TypeScript declaration from JSON config files
 */
function generateConfigTypes(configDir) {
	if (!existsSync(configDir)) {
		throw new Error(`Config directory not found: ${configDir}`)
	}

	// Files to exclude from type generation (used for error testing)
	const excludedFiles = ['invalid.json']

	const files = readdirSync(configDir)
		.filter(file => extname(file) === '.json')
		.filter(file => !excludedFiles.includes(file))

	if (files.length === 0) {
		throw new Error(`No JSON config files found in: ${configDir}`)
	}

	const configs = {}

	// Load all config files
	files.forEach(file => {
		const filePath = join(configDir, file)
		const configName = basename(file, '.json')

		try {
			const content = readFileSync(filePath, 'utf-8')
			configs[configName] = JSON.parse(content)
		} catch (error) {
			console.warn(`Warning: Failed to parse ${file}:`, error)
		}
	})

	// Generate merged type structure
	const typeDefinition = mergeJsonTypes(configs)

	// Generate the module declaration
	return `/**
 * Auto-generated type definitions from JSON configuration files
 * Generated from: ${configDir}
 * DO NOT EDIT MANUALLY - This file is automatically generated
 */

declare module '@nextnode/config-manager' {
  interface UserConfigSchema ${typeDefinition}
}

export {}
`
}

/**
 * Auto-detect user project and generate types
 */
function autoGenerateForUserProject() {
	// Find the user project root (go up from node_modules)
	const currentDir = process.cwd()
	let projectRoot = currentDir

	// If we're in node_modules/@nextnode/config-manager, go up to find project root
	if (currentDir.includes('node_modules/@nextnode/config-manager')) {
		const parts = currentDir.split('node_modules')
		projectRoot = parts[0]
	}

	const configDir = join(projectRoot, 'config')
	if (!existsSync(configDir)) {
		// No config directory found, skip generation
		return false
	}

	const outputFile = join(projectRoot, 'types', 'config.d.ts')

	try {
		// Ensure types directory exists
		const typesDir = dirname(outputFile)
		if (!existsSync(typesDir)) {
			mkdirSync(typesDir, { recursive: true })
		}

		const typeDeclaration = generateConfigTypes(configDir)
		writeFileSync(outputFile, typeDeclaration)
		console.log(`‚úÖ Generated config types: ${outputFile}`)
		console.log(`üìÅ From config directory: ${configDir}`)
		return true
	} catch (error) {
		console.error('‚ùå Failed to generate config types:', error)
		return false
	}
}

/**
 * CLI usage
 */
function main() {
	const configDir = process.argv[2] || './config'
	const outputFile = process.argv[3] || './config.d.ts'

	try {
		const typeDeclaration = generateConfigTypes(configDir)
		writeFileSync(outputFile, typeDeclaration)
		console.log(`‚úÖ Generated config types: ${outputFile}`)
		console.log(`üìÅ From config directory: ${configDir}`)
	} catch (error) {
		console.error('‚ùå Failed to generate config types:', error)
		process.exit(1)
	}
}

// Export for use as module
export { generateConfigTypes }

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
	// If no arguments provided, try auto-generation
	if (process.argv.length === 2) {
		autoGenerateForUserProject()
	} else {
		main()
	}
}
