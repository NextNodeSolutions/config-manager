import { createHash } from 'node:crypto'
import {
	existsSync,
	mkdirSync,
	readdirSync,
	readFileSync,
	statSync,
	writeFileSync,
} from 'node:fs'
import { basename, dirname, extname, join, relative, resolve } from 'node:path'

import { typeLogger } from '../utils/logger.js'
import { smartArrayUnionType } from './inference.js'

interface AutoTypeOptions {
	configDir?: string
	outputFile?: string
	force?: boolean
	silent?: boolean
}

let hasGeneratedTypes = false

/**
 * Main automatic type generation function
 * This is called automatically when config-manager is imported in a user project
 */
export const autoGenerateTypes = async (
	options: AutoTypeOptions = {},
): Promise<boolean> => {
	// Skip if already generated this session (unless forced)
	if (hasGeneratedTypes && !options.force) {
		return true
	}

	// Detect user project
	const projectRoot = detectUserProject()
	if (!projectRoot) {
		if (!options.silent && process.env.NODE_ENV !== 'test') {
			typeLogger.info('No user project detected', {
				scope: 'auto-generation',
			})
		}
		return false
	}

	// Get config directory
	const configDir = getConfigDirectory(projectRoot, options.configDir)

	// Determine output path - use provided outputFile or default to types/config.d.ts in project root
	const outputFile = options.outputFile
		? resolve(projectRoot, options.outputFile)
		: join(projectRoot, 'types', 'config.d.ts')

	const generatedTypesDir = dirname(outputFile)
	const generatedTypesFile = outputFile
	if (!existsSync(configDir)) {
		throw new Error(
			`Config directory not found: ${configDir}. Make sure the config directory exists or specify a custom path via configDir option.`,
		)
	}

	// Check if generation is needed
	if (!options.force && !hasConfigChanged(configDir, generatedTypesFile)) {
		if (!options.silent) {
			typeLogger.info('Config types are up to date', {
				scope: 'cache-check',
			})
		}
		hasGeneratedTypes = true
		return true
	}

	// Create generated types directory
	mkdirSync(generatedTypesDir, { recursive: true })

	await generateTypes(
		configDir,
		generatedTypesFile,
		projectRoot,
		options.silent,
	)
	hasGeneratedTypes = true
	return true
}

/**
 * Reset generation state (useful for testing)
 */
export const resetAutoGeneration = (): void => {
	hasGeneratedTypes = false
}

/**
 * Generate TypeScript declaration from JSON config files
 */
export const generateConfigTypes = (configDir: string): string => {
	if (!existsSync(configDir)) {
		throw new Error(`Config directory not found: ${configDir}`)
	}

	// Files to exclude from type generation (used for error testing)
	const excludedFiles = ['invalid.json']

	const files = readdirSync(configDir)
		.filter(file => extname(file) === '.json')
		.filter(file => !excludedFiles.includes(file))

	if (files.length === 0) {
		throw new Error(`No JSON config files found in: ${configDir}`)
	}

	const configs: Record<string, unknown> = {}

	// Load all config files
	files.forEach(file => {
		const filePath = join(configDir, file)
		const configName = basename(file, '.json')

		const content = readFileSync(filePath, 'utf-8')
		configs[configName] = JSON.parse(content)
	})

	// Validate consistency between environments
	validateConfigConsistency(configs)

	// Generate merged type structure
	const typeDefinition = mergeJsonTypes(configs)

	// Generate the Prisma-style type declaration
	return `/**
 * Auto-generated type definitions from JSON configuration files
 * Generated from: ${configDir}
 * DO NOT EDIT MANUALLY - This file is automatically generated
 */

// Export direct du schema généré (Prisma-style)
export interface GeneratedConfigSchema ${typeDefinition}

// Module augmentation pour remplacer ConfigSchema
declare module '@nextnode/config-manager' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface ConfigSchema extends GeneratedConfigSchema {}
}

export {}
`
}

/**
 * Collect all possible values for each property path across all configs
 */
const collectAllValues = (
	configs: Record<string, unknown>,
	currentPath = '',
	allValues = new Map<string, Set<unknown>>(),
): Map<string, Set<unknown>> => {
	const configValues = Object.values(configs).filter(
		config =>
			config !== null &&
			typeof config === 'object' &&
			!Array.isArray(config),
	) as Record<string, unknown>[]

	if (configValues.length === 0) return allValues

	// Get all possible keys from all configs
	const allKeys = new Set<string>()
	configValues.forEach(config => {
		Object.keys(config).forEach(key => allKeys.add(key))
	})

	allKeys.forEach(key => {
		const fullPath = currentPath ? `${currentPath}.${key}` : key
		const valuesForKey = new Set<unknown>()

		configValues.forEach(config => {
			if (config[key] !== undefined) {
				const value = config[key]
				if (
					typeof value === 'object' &&
					value !== null &&
					!Array.isArray(value)
				) {
					// Recursively collect for nested objects
					const nestedConfigs: Record<string, unknown> = {}
					Object.entries(configs).forEach(([env, envConfig]) => {
						if (
							envConfig &&
							typeof envConfig === 'object' &&
							!Array.isArray(envConfig) &&
							(envConfig as Record<string, unknown>)[key]
						) {
							nestedConfigs[env] = (
								envConfig as Record<string, unknown>
							)[key]
						}
					})
					collectAllValues(nestedConfigs, fullPath, allValues)
				} else {
					valuesForKey.add(value)
				}
			}
		})

		if (valuesForKey.size > 0) {
			allValues.set(fullPath, valuesForKey)
		}
	})

	return allValues
}

/**
 * Create TypeScript type from collected values with union types for multiple values
 */
const createUnionType = (values: Set<unknown>): string => {
	if (values.size === 0) return 'unknown'
	if (values.size === 1) {
		const value = Array.from(values)[0]
		if (value === null) return 'null'
		if (typeof value === 'string') return `'${value.replace(/'/g, "\\'")}'`
		if (typeof value === 'number') return value.toString()
		if (typeof value === 'boolean') return value.toString()
		if (Array.isArray(value)) {
			const uniqueTypes = new Set<string>()
			value.forEach(item => {
				if (typeof item === 'string')
					uniqueTypes.add(`'${item.replace(/'/g, "\\'")}'`)
				else if (typeof item === 'number')
					uniqueTypes.add(item.toString())
				else if (typeof item === 'boolean')
					uniqueTypes.add(item.toString())
				else if (item === null) uniqueTypes.add('null')
				else uniqueTypes.add('unknown')
			})
			const elementType = Array.from(uniqueTypes).join(' | ')
			return `readonly (${elementType})[]`
		}
		return 'unknown'
	}

	// Si toutes les valeurs sont des arrays, utilise le smart array typing
	if (Array.from(values).every(v => Array.isArray(v))) {
		return smartArrayUnionType(Array.from(values) as unknown[][])
	}

	// Sinon union normale - trier pour un ordre déterministe
	const types = Array.from(values)
		.map(value => {
			if (value === null) return 'null'
			if (typeof value === 'string')
				return `'${value.replace(/'/g, "\\'")}'`
			if (typeof value === 'number') return value.toString()
			if (typeof value === 'boolean') return value.toString()
			if (Array.isArray(value)) return 'readonly string[]'
			return 'unknown'
		})
		.sort()

	return types.join(' | ')
}

/**
 * Generate merged structure with union types
 */
const generateMergedStructure = (
	configs: Record<string, unknown>,
	allValues: Map<string, Set<unknown>>,
	currentPath = '',
	depth = 0,
): string => {
	const indent = '  '.repeat(depth)
	const configValues = Object.values(configs).filter(
		config =>
			config !== null &&
			typeof config === 'object' &&
			!Array.isArray(config),
	) as Record<string, unknown>[]

	if (configValues.length === 0) return 'Record<string, unknown>'

	// Get all possible keys from all configs and SORT them for deterministic output
	const allKeys = new Set<string>()
	configValues.forEach(config => {
		Object.keys(config).forEach(key => allKeys.add(key))
	})

	const properties = Array.from(allKeys)
		.sort()
		.map(key => {
			const fullPath = currentPath ? `${currentPath}.${key}` : key

			// Check if this path has collected values (primitive types)
			if (allValues.has(fullPath)) {
				const values = allValues.get(fullPath)!
				const unionType = createUnionType(values)
				return `${indent}  readonly ${key}: ${unionType}`
			}

			// This must be a nested object - recurse
			const nestedConfigs: Record<string, unknown> = {}
			Object.entries(configs).forEach(([env, envConfig]) => {
				if (
					envConfig &&
					typeof envConfig === 'object' &&
					!Array.isArray(envConfig) &&
					(envConfig as Record<string, unknown>)[key] &&
					typeof (envConfig as Record<string, unknown>)[key] ===
						'object' &&
					!Array.isArray((envConfig as Record<string, unknown>)[key])
				) {
					nestedConfigs[env] = (envConfig as Record<string, unknown>)[
						key
					]
				}
			})

			if (Object.keys(nestedConfigs).length > 0) {
				const nestedType = generateMergedStructure(
					nestedConfigs,
					allValues,
					fullPath,
					depth + 1,
				)
				return `${indent}  readonly ${key}: ${nestedType}`
			}

			return `${indent}  readonly ${key}: unknown`
		})

	return `{\n${properties.join('\n')}\n${indent}}`
}

/**
 * Merge multiple JSON objects and infer their combined type with union types
 */
const mergeJsonTypes = (configs: Record<string, unknown>): string => {
	// Collect all possible values for each property path
	const allValues = collectAllValues(configs)

	// Generate the structure with union types
	return generateMergedStructure(configs, allValues)
}

/**
 * Simple validation to ensure all configs have consistent structure
 * Note: 'default' is excluded as it's the base merged with all environments
 */
const validateConfigConsistency = (configs: Record<string, unknown>): void => {
	const environments = Object.keys(configs).filter(
		env =>
			env !== 'default' && // Exclude default - it's the base for all environments
			configs[env] !== null &&
			typeof configs[env] === 'object',
	)

	if (environments.length < 2) return // No validation needed for single environment

	// Get all property paths from all environments
	const getAllPaths = (obj: unknown, prefix = ''): Set<string> => {
		const paths = new Set<string>()
		if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return paths

		const record = obj as Record<string, unknown>
		Object.keys(record).forEach(key => {
			const fullPath = prefix ? `${prefix}.${key}` : key
			paths.add(fullPath)
			if (
				typeof record[key] === 'object' &&
				record[key] !== null &&
				!Array.isArray(record[key])
			) {
				getAllPaths(record[key], fullPath).forEach(path =>
					paths.add(path),
				)
			}
		})
		return paths
	}

	// Collect all paths from all environments
	const allPaths = new Map<string, Set<string>>() // path -> Set of environments that have it
	environments.forEach(env => {
		const paths = getAllPaths(configs[env])
		paths.forEach(path => {
			if (!allPaths.has(path)) allPaths.set(path, new Set())
			allPaths.get(path)!.add(env)
		})
	})

	// Check for inconsistencies
	const errors: string[] = []
	allPaths.forEach((envsWithPath, path) => {
		const missingEnvs = environments.filter(env => !envsWithPath.has(env))
		if (missingEnvs.length > 0) {
			const hasEnvs = Array.from(envsWithPath)
			errors.push(
				`Property '${path}' exists in [${hasEnvs.join(', ')}] but missing in [${missingEnvs.join(', ')}]`,
			)
		}
	})

	if (errors.length > 0) {
		throw new Error(
			`❌ Configuration consistency validation failed:\n\n${errors.join('\n')}\n\nAll environments must have the same structure.`,
		)
	}
}

/**
 * Detect if we're running in a user project by checking for a config directory
 */
const detectUserProject = (): string | null => {
	const currentDir = process.cwd()

	// Check if we're in the config-manager package itself
	const packageJsonPath = join(currentDir, 'package.json')
	if (existsSync(packageJsonPath)) {
		const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'))
		if (packageJson.name === '@nextnode/config-manager') {
			// We're in the config-manager package itself, don't auto-generate
			return null
		}
	}

	const configPath = join(currentDir, 'config')
	if (existsSync(configPath) && statSync(configPath).isDirectory()) {
		return currentDir
	}

	return null
}

/**
 * Get the config directory path (always config/ at project root)
 */
const getConfigDirectory = (
	projectRoot: string,
	customConfigDir?: string,
): string => {
	if (customConfigDir) {
		return join(projectRoot, customConfigDir)
	}
	return join(projectRoot, 'config')
}

/**
 * Check if config files have changed since last generation
 * Uses content-based comparison to avoid unnecessary regenerations
 */
const hasConfigChanged = (configDir: string, outputFile: string): boolean => {
	if (!existsSync(outputFile)) return true

	try {
		// Generate what the new content would be
		const newContent = generateConfigTypes(configDir)
		const newHash = createHash('md5').update(newContent).digest('hex')

		// Read the existing file and extract its hash
		const existingContent = readFileSync(outputFile, 'utf-8')
		const hashMatch = existingContent.match(
			/Generated hash: ([a-f0-9]{32})/,
		)

		if (!hashMatch) {
			// No hash found, but let's compare content directly (excluding hash line)
			const existingWithoutHash = existingContent.replace(
				/\* Generated hash: [a-f0-9]{32}\n/,
				'',
			)
			const newWithoutHash = newContent
			return existingWithoutHash.trim() !== newWithoutHash.trim()
		}

		const existingHash = hashMatch[1]
		return existingHash !== newHash
	} catch {
		// If there's any error in comparison, regenerate to be safe
		return true
	}
}

/**
 * Validate that the output path is safe (no path traversal)
 */
const validateOutputPath = (
	outputFile: string,
	projectRoot: string,
): boolean => {
	const resolvedOutput = resolve(outputFile)
	const resolvedProject = resolve(projectRoot)
	const relativePath = relative(resolvedProject, resolvedOutput)

	// Check if the path tries to escape the project directory
	return !relativePath.startsWith('..')
}

/**
 * Generate types using our existing generator
 */
const generateTypes = async (
	configDir: string,
	outputFile: string,
	projectRoot: string,
	silent = false,
): Promise<void> => {
	// Validate output path for security
	if (!validateOutputPath(outputFile, projectRoot)) {
		throw new Error(
			`Invalid output path: ${outputFile}. Path traversal detected.`,
		)
	}

	// Ensure types directory exists
	const typesDir = dirname(outputFile)
	if (!existsSync(typesDir)) {
		mkdirSync(typesDir, { recursive: true })
	}

	// Generate type content
	const typeContent = generateConfigTypes(configDir)

	// Add hash of the generated content for precise change detection
	const contentHash = createHash('md5').update(typeContent).digest('hex')
	const contentWithHash = typeContent.replace(
		'* DO NOT EDIT MANUALLY - This file is automatically generated',
		`* DO NOT EDIT MANUALLY - This file is automatically generated\n * Generated hash: ${contentHash}`,
	)

	writeFileSync(outputFile, contentWithHash)

	// Create relative paths from project root
	const relativeOutputFile = relative(projectRoot, outputFile)
	const relativeConfigDir = relative(projectRoot, configDir)

	if (!silent) {
		typeLogger.info(
			`Generated types: ${relativeOutputFile} (from ${relativeConfigDir})`,
			{
				scope: 'type-generation',
			},
		)
	}
}
